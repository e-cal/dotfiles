#!/usr/bin/env python

import os
import sys
import readline
from pathlib import Path
from typing import Callable
from uuid import uuid4 as uuid

HOME = Path.home()
IN_TMUX = os.getenv("TMUX") is not None

SHELL = "zsh"
STARTCMD = f"sleep 0.1 && triangles && echo; exec {SHELL}"

ACTION_ICON = "ïƒš "

PROJECT_DIR = HOME / "projects"


def run_cmd(cmd):
    return os.popen(cmd).read().strip()


ACTIVE_SESSIONS = run_cmd("tmux ls 2>/dev/null | awk '{print $1}' | sed 's/://'").splitlines()

actions: dict[str, Callable] = {}


def action(func):
    actions[func.__name__] = func
    return func


NIX_PYTHON_SHELL = """{ pkgs ? import <nixpkgs> { } }:

let
  myPython = pkgs.python311;
  pythonPackages = pkgs.python311Packages;

  pythonWithPkgs = myPython.withPackages (pythonPkgs:
    with pythonPkgs; [
      ipython
      pip
      setuptools
      virtualenvwrapper
      wheel
      black
    ]);

  # troublesome packages go here
  extraBuildInputs = with pkgs; [
    # pythonPackages.pandas
    # pythonPackages.numpy
    # pythonPackages.torch
  ];

  buildInputs = with pkgs;
    [ clang llvmPackages_16.bintools rustup ] ++ extraBuildInputs;

  lib-path = with pkgs; lib.makeLibraryPath buildInputs;

in pkgs.mkShell {
  buildInputs = [
    pythonWithPkgs
    pkgs.readline
    pkgs.libffi
    pkgs.openssl
    pkgs.git
    pkgs.openssh
    pkgs.rsync
  ] ++ extraBuildInputs;

  shellHook = ''
    SOURCE_DATE_EPOCH=$(date +%s)
    export "LD_LIBRARY_PATH=$LD_LIBRARY_PATH:${lib-path}"
    [[ ! -f .venv ]] && setvenv
    VENV=$(cat .venv)
    source $VIRTUALENV_HOME/$VENV/bin/activate
    deactivate
    exec zsh
  '';
}
"""


def fzf_menu(options: list[str], title="menu", binds: dict[str, str] | None = None, fzf_options=""):
    fzf_binds = ""
    if binds:
        fzf_binds = '--bind="'
        for key, cmd in binds.items():
            fzf_binds += f"{key}:{cmd},"
        fzf_binds = fzf_binds[:-1] + '"'

    options = sorted(options, key=lambda x: (ACTION_ICON in x, x != "main", -len(x), x))
    options_str = "\n".join(options)
    try:
        res = run_cmd(f'echo "{options_str}" | fzf --header="{title}" --info="hidden" {fzf_options} {fzf_binds}').strip()
        if not res: exit()
        return res
    except:  # noqa
        exit(1)


def session_exists(session):
    return os.popen(f"tmux has-session -t={session} &>/dev/null").close() is None


def start_session(session, work_dir: Path | None = None, run=None):
    if work_dir and not work_dir.exists(): exit(1)
    cmd = [f"tmux new -s {session} -d ", f'"{STARTCMD}"']
    if work_dir:
        cmd.insert(1, f"-c {work_dir}")

    run_cmd(" ".join(cmd))


def attach(session, work_dir: Path | None = None):
    session = session.replace(".", "_")
    if not session_exists(session):
        start_session(session, work_dir)
    attach_cmd = "tmux switch" if IN_TMUX else "tmux attach"
    run_cmd(f"{attach_cmd} -t {session}")

    if work_dir and (work_dir / "shell.nix").exists():
        run_cmd(f"tmux send-keys -t {session} 'nix-shell' ENTER")


def startup(kind="main"):
    wtitles = run_cmd("hyprctl clients | rg -s title | awk '{ print $2 }'").splitlines()

    if kind == "scratch":
        if "scratch" not in wtitles:
            run_cmd("kitty --title scratch zsh -c 'tm attach scratch'")
    elif kind == "ask":
        if "scratch-ask" not in wtitles:
            run_cmd('kitty --title scratch-ask zsh -c \'tm attach scratch-ask "" "scratch-ask;exit"\'')
    else:
        if session_exists("main"):
            sys.argv = []
            main()
        else:
            print("attaching main")
            attach("main")


@action
def new(name=None, work_dir=None):
    if not work_dir:
        work_dir = run_cmd(
            """find ~ -maxdepth 5 -type d \
                -not -path '*/.vscode-insiders/*' \
                -not -path '*/.mozilla/*' \
                -not -path '*/.cache/*' \
                -not -path '*/.local/*' \
                -not -path '*/.minecraft/*' \
                -not -path '*/.thunderbird/*' \
                -not -path '*/.config/*/*' \
                -not -path '*/.dotfiles/global/dot-config/*/*' \
                -not -path '*/projects/*/*' \
                -not -path '*/notes/*/*' \
                -not -path '*/.git/*' \
                2>/dev/null |\
            sed 's/\.\///' |\
            sed 's/\/home\/ecal/~/' |\
            fzf --border --height=100% --layout=reverse"""
        )
    if not work_dir: exit()

    work_dir = Path(work_dir).expanduser()
    name = work_dir.name

    readline.set_startup_hook(lambda: readline.insert_text(name))  # type: ignore
    try:
        name = input("session name: ")
    finally:
        readline.set_startup_hook()
    if not name: exit()

    print(work_dir)
    attach(name, work_dir)


@action
def kill(session=None):
    if not ACTIVE_SESSIONS:
        print("no active sessions")
        exit()

    if not session:
        opts = [s for s in ACTIVE_SESSIONS if s != "main"] + [f"{ACTION_ICON}tmux", f"{ACTION_ICON}current"]
        session = fzf_menu(opts, "kill")

    if session == f"{ACTION_ICON}tmux":
        run_cmd('pgrep -f "bash.*tm startup" | xargs -n1 kill tmux kill-server')
        run_cmd("tmux kill-server")
    elif session == f"{ACTION_ICON}current":
        session = run_cmd("tmux display-message -p '#S'")
        attach("main")
        run_cmd(f"tmux kill-session -t {session}")
    else:
        if session == run_cmd("tmux display-message -p '#S'"): attach("main")
        run_cmd(f"tmux kill-session -t {session}")


@action
def reset():
    if not IN_TMUX:
        print("not in tmux")
        exit()
    cur = run_cmd("tmux display-message -p '#S'")
    tmp = uuid()
    run_cmd(
        f'tmux new -s {tmp} -d && tmux switch -t {tmp} && tmux send-keys -t {tmp} "tm kill {cur} && tm attach {cur}; tm kill {tmp}" ENTER'
    )


@action
def project(sel=None):
    projects = {x.name: x for x in PROJECT_DIR.iterdir() if x.is_dir()}

    projects[f"{ACTION_ICON}new"] = None  # type: ignore

    if not sel:
        sel = fzf_menu(list(projects.keys()), title=PROJECT_DIR.name)

    if sel.upper() == f"{ACTION_ICON}new":
        name = input("project name / repo: ")
        if not name: return

        if name in ["repo", "repos", "list", "search", "clone"]:
            repos = run_cmd("gh repo list --limit 1000 --json name -q '.[].name'")
            repo = fzf_menu(repos.split(), "repo")
            name = "e-cal/" + repo
        if name.startswith("http") or name.startswith("git"):
            url = name
            name = name.split("/")[-1].split(".")[0]
            run_cmd(f"git clone {url} $HOME/projects/{name}")
        elif "/" in name:
            run_cmd(f"gh repo clone {name} $HOME/projects/{name.split('/')[-1]}")
            name = name.split("/")[-1]
        else:
            PROJECT_DIR.joinpath(name).mkdir(parents=True, exist_ok=True)
            if input("init git repo? ").lower() in ("y", "yes"):
                run_cmd(
                    f"cd $HOME/projects/{name} && touch README.md && git init && git add . && git commit -m 'Batman' && gh repo create -s . --push --private"
                )
                print("Initialized a private repo.")

        if input("init python nix shell? ").lower() in ("y", "yes"):
            with open(PROJECT_DIR.joinpath(name, "shell.nix"), "w") as f:
                f.write(NIX_PYTHON_SHELL)
            print("Initialized python nix shell.")

        attach(name, PROJECT_DIR.joinpath(name))
        return

    attach(sel.replace(".", "_"), projects[sel])


def handle_args():
    op = sys.argv[1]
    if op not in globals():
        expand = {
            "a": "attach",
            "n": "new",
            "r": "reset",
            "k": "kill",
        }
        op = expand.get(op, op)
    if op in ("p", "project", "projects"):
        if len(sys.argv) > 2:
            project(sys.argv[2])
        else:
            project()
        exit()
    elif op in globals():
        try:
            globals()[op](*sys.argv[2:])
        except TypeError as e:
            print(e)
            exit(1)
    else:
        print("invalid command")
        exit(1)


def main():
    if len(sys.argv) > 1:
        handle_args()
        exit()

    if len(ACTIVE_SESSIONS) == 0:
        print("starting tmux server...")
        startup()
        return

    options = ACTIVE_SESSIONS + [ACTION_ICON + a for a in actions]
    sel = fzf_menu(
        options,
        "main menu",
        binds={
            "ctrl-d": "execute(tm kill {})+reload(tm get_menu refresh)",
        },
    )
    if not sel: exit()

    sel = sel.replace(ACTION_ICON, "")

    if sel in ACTIVE_SESSIONS: attach(sel)
    else: actions[sel]()


if __name__ == "__main__": main()
